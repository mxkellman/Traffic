<!DOCTYPE html>
<meta charset="utf-8">
	<style>
		body {
			margin: 0px;
			padding: 0px;
		}
		.node {
			stroke: #fff;
			stroke-width: 1px;
		}
		
		.link {
			stroke: #999;
			stroke-opacity: .3;
		}

		.link-source {
			stroke: #900;
			stroke-opacity: .5;
		}
		
		.link-target {
			stroke: #090;
			stroke-opacity: .5;
		}

	</style>
<body>
	<svg></svg>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<script>
	
	var w = window,
		d = document,
		e = d.documentElement,
		g = d.getElementsByTagName('body')[0],
		width = w.innerWidth || e.clientWidth || g.clientWidth,
		height = w.innerHeight || e.clientHeight || g.clientHeight,
		mindim = width < height ? width : height;
		svg = d3.select("body").select("svg")
		  .attr("width", width)
		  .attr("height", height),
		pairs = [],
		pairMap = [],
		network = [],
		paths = {},
		links = {},
		nodes = {},
		viewMax = 0,
		rideMax = 0;
		
	// Settings
	var rideMin = 500,
		radiusMin = 5,
		radiusMax = width / 20,
		linkDistMin = mindim * 0.35,
		linkDistMax = radiusMax + 10
		linkStrMin = 0.5,
		linkStrMax = 0.8,
		linkWidthMin = 1,
		linkWidthMax = radiusMax,
		gravity = 0.05,
		charge = -600,
//		pageMap = ["Entry","Exit"],
		pageMap = [],
		pages = [
/*
			{name:"Entry", views:0, category:"None", fixed:true, y:height/2, x:radiusMax},
			{name:"Exit", views:0, category:"None",  fixed:true, y:height/2, x:width - radiusMax}
*/
		],
		colors = ["#393b79", "#6b6ecf", "#637939", "#b5cf6b", "#8c6d31", "#e7ba52", "#843c39", "#d6616b", "#7b4173", "#ce6dbd"];
	
	// Scales
	var radiusScale = d3.scale.sqrt(),
		colorScale = d3.scale.ordinal(),
		linkDistScale = d3.scale.sqrt(),
		linkStrengthScale = d3.scale.sqrt(),
		linkWidthScale = d3.scale.sqrt(),
	    force = d3.layout.force();
	
	d3.tsv("Path-1h-min.tsv", function(error, data) {
		data.forEach(function(d, i) {
/*
			if (!paths[d.sessID]) { 
				addPage("Entry", d);
			}
*/
			var pageName = d.Category + ' > ' + d.Page;
			addPage(pageName, d);
		});

/*
		var pathKeys = d3.keys(paths);
		pathKeys.forEach(function(sessID) {
			var options = {};
			options.sessID = sessID;
			addPage("Exit", options);
		});
*/
		
		function addPage(pageName, d) {
			var pageIndex = pageMap.indexOf(pageName);
			if (pageIndex === -1 ) { 
				pageMap.push(pageName);
				pageIndex = pageMap.indexOf(pageName);
				pages.push({name:d.Page, views:0, category:d.Category});
			}			
			pages[pageIndex].views++;
			if (pages[pageIndex].views > viewMax) { viewMax = pages[pageIndex].views; }
			if (!paths[d.sessID]) { paths[d.sessID] = []; }
			var path = paths[d.sessID];
			path.push(pageName);
			var length = path.length;
			var i = 0;
			while (i < length - 1) {
				addPair(path[i], path[length-1]);
				i++;
			}
/*
			if (length > 1) {
				addPair(path[length-2], path[length-1]);
			}
*/
		}

		function addPair(pageNamePrev, pageName) {
			var pageIndex = pageMap.indexOf(pageName);
			var pageIndexPrev = pageMap.indexOf(pageNamePrev);
			var name1 = pageName;
			var name2 = pageNamePrev;
			var index1 = pageIndex;
			var index2 = pageIndexPrev;
			
			if (index2 < index1) {
				name2 = pageName;
				name1 = pageNamePrev;
				index2 = pageIndex;
				index1 = pageIndexPrev;
			}
			
			var pairName = pageNamePrev + ' & ' + pageName;
			var pairIndex = pairMap.indexOf(pairName);
			if (pairIndex === -1) {
				pairMap.push(pairName);
				pairs.push({source:pageIndexPrev, target:pageIndex, rides:0});
				pairIndex = pairMap.indexOf(pairName);
			}
			pairs[pairIndex].rides++;
			if (pairs[pairIndex].rides > rideMax) { rideMax = pairs[pairIndex].rides; }
		}
/*
		function addPair(pageNamePrev, pageName) {
			var pairName = pageNamePrev + ' & ' + pageName;
			var pairIndex = pairMap.indexOf(pairName);
			if (pairIndex === -1) {
				pairMap.push(pairName);
				var pageIndex = pageMap.indexOf(pageName);
				var pageIndexPrev = pageMap.indexOf(pageNamePrev);
				pairs.push({source:pageIndexPrev, target:pageIndex, rides:0});
				pairIndex = pairMap.indexOf(pairName);
			}
			pairs[pairIndex].rides++;
			if (pairs[pairIndex].rides > rideMax) { rideMax = pairs[pairIndex].rides; }
		}
*/

		radiusScale
			.domain([1,viewMax])
			.range([radiusMin,radiusMax]);

		colorScale.range(colors);
		
		linkDistScale
			.domain([1,rideMax])
			.range([linkDistMin, linkDistMax]);
		
		linkStrengthScale
			.domain([1,rideMax])
			.range([linkStrMin, linkStrMax]);

		linkWidthScale
            .domain([1, rideMin, rideMax])
            .range([0, linkWidthMin,linkWidthMax]);

        force
			.gravity(gravity)
			.charge(charge)
			.size([width, height])
			.nodes(pages)
			.links(pairs)
			.linkDistance(function(d) { return linkDistScale(d.rides)})
			.linkStrength(function(d, i) { 
				if (i > -1) { return linkStrengthScale(d.rides) }
				else { return 0 }
			})
			.start();

        links = svg.selectAll(".link")
			.data(pairs)
			.enter().append("line")
			.attr("class", "link")
			.style("stroke-width", function(d) { return linkWidthScale(d.rides); });
		
		nodes = svg.selectAll(".node")
			.data(pages)
			.enter().append("circle")
				.attr("class", "node")
				.attr("r", function(d) { return radiusScale(d.views); } )
				.style("fill", function(d) { return colorScale(d.category); })
				.call(force.drag)
				.on("mouseover", function(d) { showLinks(d); })
				.on("mouseout", function(d) { resetLinks(); });
		
		force.on("tick", function() {
			links.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });
		
			var q = d3.geom.quadtree(pages),
			    i = 2,
			    n = pages.length;
			
			while (++i < n) q.visit(collide(pages[i]));
			
			svg.selectAll(".node")
			    .attr("cx", function(d) { return d.x; })
			    .attr("cy", function(d) { return d.y; });
		  });
	});

	function showLinks(node) {
        links
	        .style("stroke-width", function(d) { 
				if (d.source.index === node.index || d.target.index === node.index) { 
					return linkWidthScale(d.rides); 
				} else { return 0; }
			})
			.attr("class", function(d) {
				if (d.source.index === node.index) { return "link-source"; }
				if (d.target.index === node.index) { return "link-target"; }
			});
	}

	function resetLinks() {
        links
        	.style("stroke-width", function(d) { return linkWidthScale(d.rides); })
        	.attr("class", "link");
	}

	function collide(node) {
		var r = radiusScale(node.views) + 15,
			nx1 = node.x - r,
			nx2 = node.x + r,
			ny1 = node.y - r,
			ny2 = node.y + r;
		return function(quad, x1, y1, x2, y2) {
			if (quad.point && (quad.point !== node)) {
				var x = node.x - quad.point.x,
				    y = node.y - quad.point.y,
				    l = Math.sqrt(x * x + y * y),
				    r = radiusScale(node.views) + radiusScale(quad.point.views);
				if (l < r) {
					l = (l - r) / l * 0.5;
					node.x -= x *= l;
					node.y -= y *= l;
					quad.point.x += x;
					quad.point.y += y;
				}
			}
			return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
		};

	}
	
	</script>
</body>
